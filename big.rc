show_more = false
autofight_stop = 0
pizza = pineapple

#auto-select MiBe (maybe switch later)
weapon += hand axe
species += Mi
background += Be

#Only pick up food and money until further implementation
autopickup = %$
autopickup_exceptions += <rotten

#only stop autotravel on sight of stairs right now, not on items
explore_stop = stairs,items

###############################
# Generic Functions           #
###############################

# general.rc functions:

# magic(string): sends a string for crawl to process
# find_min(arr): finds the min value of an array
# max(a,b): returns the larger value of a and b
# sign(a): returns 1 if input is positive, -1 if negative, 0 else
# length(arr): returns the length of an array
# find(arr, string): finds if a string is in an arr, (-1,-1) is returned otherwise

{

--sends input string as keys to Crawl, I wish I knew why three EoT chars were needed
function magic(command)
  crawl.process_keys(command .. string.char(27) .. string.char(27) .. string.char(27) .. string.char(27))
end

function find_min(arr)
    local min = arr[1]
    for i = 2, length(arr) do
      if (arr[i] < min) then
        min = arr[i]
      end
    end
    return min
end

function max(a, b)
    if (a > b) then
      return a
    else
      return b
    end
end

function sign(a)
    if (a > 0) then
      return 1
    elseif (a < 0) then
      return -1
    else
      return 0
    end
end

function length(arr)
    local size = 0
    for index, value in ipairs(arr) do
      size = size + 1
    end
    return size
end

function find(patterns, text)
    local begin, final
    for i, pattern in ipairs(patterns) do
      begin, final = string.find(text, (pattern))
      if begin ~= nil then
        return begin, final
      end
    end
    return -1, -1
end


function is_harmless(mon)
  local pos1, pos2
  pos1, pos2 = find(list_of_harmless, mon:name())
  if (pos1 == -1) then
    return false
  else
    return true
  end
end

function detect_monster_radius(rad, option)
  local neg_rad = -1 * rad
  local close_monster
  local easy = {}
  local hard = {}
  local nasty = {}
  for x = 0, 2*rad do
    close_monster = monster.get_monster_at(neg_rad + x, rad)
    if close_monster then
      if (not is_harmless(close_monster)) then
        if (option == "single") then
          return neg_rad + x, rad
        elseif (close_monster:threat() == 1) then
          table.insert(easy, close_monster)
        elseif (close_monster:threat() == 2) then
          table.insert(hard, close_monster)
        elseif (close_monster:threat() == 3) then
          table.insert(nasty, close_monster)
        end
      end
    end
  end
  for x = 0, 2*rad do
    close_monster = monster.get_monster_at(neg_rad + x, neg_rad)
    if close_monster then
      if (not is_harmless(close_monster)) then
        if (option == "single") then
          return neg_rad + x, neg_rad
        elseif (close_monster:threat() == 1) then
          table.insert(easy, close_monster)
        elseif (close_monster:threat() == 2) then
          table.insert(hard, close_monster)
        elseif (close_monster:threat() == 3) then
          table.insert(nasty, close_monster)
        end
      end
    end
  end
  for x = 1, 2*rad - 1 do
    close_monster = monster.get_monster_at(neg_rad, neg_rad + x)
    if close_monster then
      if (not is_harmless(close_monster)) then
        if (option == "single") then
          return neg_rad, neg_rad+x
        elseif (close_monster:threat() == 1) then
          table.insert(easy, close_monster)
        elseif (close_monster:threat() == 2) then
          table.insert(hard, close_monster)
        elseif (close_monster:threat() == 3) then
          table.insert(nasty, close_monster)
        end
      end
    end
  end
  for x = 1, 2*rad - 1 do
    close_monster = monster.get_monster_at(rad, neg_rad + x)
    if close_monster then
      if (not is_harmless(close_monster)) then
        if (option == "single") then
          return rad, neg_rad+x
        elseif (close_monster:threat() == 1) then
          table.insert(easy, close_monster)
        elseif (close_monster:threat() == 2) then
          table.insert(hard, close_monster)
        elseif (close_monster:threat() == 3) then
          table.insert(nasty, close_monster)
        end
      end
    end
  end
  if (option == "single") then
    return 0, 0
  else
    return nasty, hard, easy
  end
end

function find_closest_monster()
  local radius
  local x, y
  x = 0
  y = 0
  for radius = 1, 7 do
    x, y = detect_monster_radius(radius, "single")
    if (x ~= 0 or y ~= 0) then
      return x, y
    end
  end
  return 0, 0
end

--Make this smarter
function detect_monsters()
  return find_closest_monster()
end

function detect_danger()
  local danger = 0
  for radius = 1, 7 do
    x,y,z = detect_monster_radius(radius, "all")
    danger = danger + table.getn(x)*4
    danger = danger + table.getn(y)*2
    danger = danger + table.getn(z)
  end
  crawl.mpr(tostring(danger))
  return danger
end

----------------------
-- Moving Functions --
----------------------

function autotravel()
  magic("o")
end

function autoattack()
  magic("\t")
end

function descend()
  magic("G>")
end

-- This function is outdated to when food was in several different categories
function eat_permafood()
  local this_item
  local i, a, b
  for i = 0, 51 do
    this_item = items.inslot(i)
    if (this_item ~= nil) then
      a, b = find(list_of_permafood, this_item:name())
      if (a ~= -1) then
        magic("e" .. items.index_to_letter(i))
        return 0
      end
    end
  end
  crawl.mpr("No permafood, this is a problem")
  return 1
end

function eat()
  eat_permafood()
end

function rest()
  magic("s")
end

-------------------
-- Main Function --
-------------------

--hunger: 4 = satiated
--        3 = hungry
--        2 = very hungry
--        1 = near starving
--        0 = starving

function choose_stat_gain()
  return "s"
end

--This is the function which runs automatically at the start of the turn by Crawl.
--Determines the state of the game, and executes the appropriate action
function ready()
  local x,y = detect_monsters()
  local hung = you.hunger()
  local cur_danger = detect_danger()
  local chp, mhp = you.hp()
  local berserk = you.berserk()
 
  crawl.more_autoclear(1)
  crawl.more_autoclear(1)

  if (prev_turn == you.turns()) then
    --crap, we failed to do anything this turn... Hopefully because the floor is done
    non_moves = non_moves + 1
    crawl.mpr(tostring(non_moves))
  else
    non_moves = 0
  end
  if (non_moves > 20) then
    cur_goal = "descend"
    descend()
    non_moves = 0
  else
    if (hung == 0) then
      cur_goal = "eat"
      eat()
    else
      if (x ~= 0 or y ~= 0) then
        cur_goal = "fight"
        crawl.mpr(tostring(cur_danger))
        if ((cur_danger > danger_limit) and (berserk == false)) then
            magic("aa")
        end
        autoattack()
        --eventually change this to retreat/fight
      else
        if (hung <= 2) then
          cur_goal = "eat"
          eat()
        else
          if ((berserk) or (chp < 0.9*mhp) or (you.exhausted())) then
            rest()  
          else
            autotravel()
          end
        end
      end
    end
  end
  prev_turn = you.turns()
end
}

######################################
# Initialization of important fields #
######################################

:cur_goal = "explore"
:non_moves = 0
:prev_danger = 0
:prev_turn = -1
:list_of_permafood = {"ration"}
:list_of_harmless = {"plant", "bush", "fungus"}
:list_of_dangerous = {"orc warrior", "orc priest"}
:danger_limit = 2
:initialized = 0
