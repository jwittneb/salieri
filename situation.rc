## Current Functions:

## is_harmless(mon): returns true if harmless (plant, etc.)
## detect_monster_radius(rad, option): Find all monsters at an exact radius, option always "single"
##                                     for now
## detect_monsters(): wrapper for detect_monster_radius
## find_closest_monster(): returns the x and y coordinate of the closest monster, using

<

function find(patterns, text)
    local begin, final
    for i, pattern in ipairs(patterns) do
      begin, final = string.find(text, (pattern))
      if begin ~= nil then
        return begin, final
      end
    end
    return -1, -1
end

function is_harmless(mon)
  local pos1, pos2
  pos1, pos2 = find(list_of_harmless, mon:name())
  if (pos1 == -1) then
    return false
  else
    return true
  end
end

--find all monsters at an exact radius
--options:
--  "single": returns the coordinate of one monster at this radius, if it exists
-- "all": sorts monsters in easy, hard, and nasty at given radius
function detect_monster_radius(rad, option)
  local neg_rad = -1 * rad
  local close_monster
  local easy = {}
  local hard = {}
  local nasty = {}
  for x = 0, 2*rad do
    close_monster = monster.get_monster_at(neg_rad + x, rad)
    if close_monster then
      assert(close_monster:speed_description())
      crawl.mpr(close_monster:speed_description(), 1)
      if (not is_harmless(close_monster)) then
        if (option == "single") then
          return neg_rad + x, rad
        elseif (close_monster:threat() == 1) then
          table.insert(easy, close_monster)
        elseif (close_monster:threat() == 2) then
          table.insert(hard, close_monster)
        elseif (close_monster:threat() == 3) then
          table.insert(nasty, close_monster)
        end
      end
    end
  end
  for x = 0, 2*rad do
    close_monster = monster.get_monster_at(neg_rad + x, neg_rad)
    if close_monster then
      if (not is_harmless(close_monster)) then
        if (option == "single") then
          return neg_rad + x, neg_rad
        elseif (close_monster:threat() == 1) then
          table.insert(easy, close_monster)
        elseif (close_monster:threat() == 2) then
          table.insert(hard, close_monster)
        elseif (close_monster:threat() == 3) then
          table.insert(nasty, close_monster)
        end
      end
    end
  end
  for x = 1, 2*rad - 1 do
    close_monster = monster.get_monster_at(neg_rad, neg_rad + x)
    if close_monster then
      if (not is_harmless(close_monster)) then
        if (option == "single") then
          return neg_rad, neg_rad+x
        elseif (close_monster:threat() == 1) then
          table.insert(easy, close_monster)
        elseif (close_monster:threat() == 2) then
          table.insert(hard, close_monster)
        elseif (close_monster:threat() == 3) then
          table.insert(nasty, close_monster)
        end
      end
    end
  end
  for x = 1, 2*rad - 1 do
    close_monster = monster.get_monster_at(rad, neg_rad + x)
    if close_monster then
      if (not is_harmless(close_monster)) then
        if (option == "single") then
          return rad, neg_rad+x
        elseif (close_monster:threat() == 1) then
          table.insert(easy, close_monster)
        elseif (close_monster:threat() == 2) then
          table.insert(hard, close_monster)
        elseif (close_monster:threat() == 3) then
          table.insert(nasty, close_monster)
        end
      end
    end
  end
  if (option == "single") then
    return 0, 0
  else
    return nasty, hard, easy
  end
end

function find_closest_monster()
  local radius
  local x, y
  x = 0
  y = 0
  for radius = 1, 7 do
    x, y = detect_monster_radius(radius, "single")
    if (x ~= 0 or y ~= 0) then
      return x, y
    end
  end
  return 0, 0
end

-- TODO: this function is called like 3 times per turn, stop this
--Make this smarter
function detect_monsters()
  return find_closest_monster()
end

function detect_danger()
  local danger = 0
  for radius = 1, 7 do
    x,y,z = detect_monster_radius(radius, "all")
    danger = danger + table.getn(x)*4
    danger = danger + table.getn(y)*2
    danger = danger + table.getn(z)
  end
  crawl.mpr(tostring(danger))
  return danger
end

-- helper function for chokepoint to make things more readable
function is_wall(feat)
  return ((not travel.feature_traversable(feat)) and (feat ~= "unseen"))
end

-- could be made more efficient 
-- returns -1 if no chokepoint can be found
-- looks for patterns, where X = wall, . = traversable space
-- XX
-- ..
-- XX
--
-- X.X
-- X.X
function find_nearby_chokepoints()
  for x = -7, 5 do
    for y = -7, 5 do      
      -- Take all 3x3 grids (minus bottom-right block) to find vert/horiz chokepoints
      -- We miss chokepoints that are exactly in the bottom-right corner doing this, 
      -- this can be easily fixed, but not a priority
      x1y1 = view.feature_at(x,y)
      x2y1 = view.feature_at(x+1,y)
      x3y1 = view.feature_at(x+2,y)
      x1y2 = view.feature_at(x,y+1)
      x2y2 = view.feature_at(x+1,y+1)
      x3y2 = view.feature_at(x+2,y+1)
      x1y3 = view.feature_at(x,y+2)
      x2y3 = view.feature_at(x+1,y+2)

      -- vertical chokepoint
      if (is_wall(x1y1) and is_wall(x1y2) and is_wall(x3y1) and is_wall(x3y2) and travel.feature_traversable(x2y1) and travel.feature_traversable(x2y2)) then
        crawl.mpr("vertical: " .. tostring(x) .. "," .. tostring(y))
      end

      -- horizontal chokepoint
      if (is_wall(x1y1) and is_wall(x2y1) and is_wall(x1y3) and is_wall(x2y3) and travel.feature_traversable(x1y2) and travel.feature_traversable(x2y2)) then
        crawl.mpr("horizontal: " .. tostring(x) .. "," .. tostring(y))
      end
    end
  end
end

-- This functions is still dumb because it would recognize deep water as part of a chokepoint
-- even against monsters that can swim (i.e. hydra, crocs)
function find_optimal_chokepoint()
  local x, y
  -- figure out what direction the danger is in, that
  -- way we can look for chokepoints in a safer direction
  x,y = detect_monsters()
  chokepoints = find_nearby_chokepoints

  -- no nearby chokepoints
  if (chokepoints == -1) then
    return -1
  end

  for i,v in ipairs(chokepoints) do
    --if the direction of the chokepoint is opposite that of
    --the enemies we are good. Maybe make this smarter so that
    --it returns the closest one as well.
    if (v[1]*x < 0 and v[2]*y < 0) then
        return v
    end
  end

  --no suitable chokepoints
  return -2
end
>
