# Current status (for v0.23):
########################
# Current Capabilities #
########################
# autotravel around and kill things
# does not attack harmless plants
# go down stairs once floor is complete
# will eat permafood when very hungry
# Rest when low on hp
# deal with stat increases/level up
# Berserking as an option

###################
# Next Objectives #
###################
# Equipment
# Cursed Equipment
# Really dumb fleeing
# Change fleeing to actually be intelligent
# Dealing with Water between char and enemies
# Deal with invisible enemies
# Deal with status effects (confusion, etc.)
# Only Berserk when next to enemy
# other god abilities
# dealing with shops
# better fleeing
# Focus on important enemies (ie. orc priests)
# Make it so we do attack dangerous plants (oklob plants)
# Deal with no permafood scenario

# ongoing: equipment

show_more = false
autofight_stop = 0
pizza = pineapple

#auto-select MiBe (maybe switch later)
weapon += hand axe
species += Mi
background += Be

# it is easier to auto-pickup everything and evaluate it in the inventory rather than
# evaluate it's value on the ground. This might change as inventory management becomes 
# a problem
autopickup = $?!:/%|\[)
autopickup_exceptions += <rotten

#only stop autotravel on sight of stairs and items right now
explore_stop = stairs,items
explore_stop += greedy_pickup

###############################
# Generic Functions           #
###############################

# general.rc functions:

# magic(string): sends a string for crawl to process
# find_min(arr): finds the min value of an array
# max(a,b): returns the larger value of a and b
# sign(a): returns 1 if input is positive, -1 if negative, 0 else
# length(arr): returns the length of an array
# find(arr, string): finds if a string is in an arr, (-1,-1) is returned otherwise
# combine(arr1, arr2): combine two arrays into one

include = general.rc

#####################################
# Determining Situation Functions   #
#####################################

# situation.rc functions:

# is_harmless(mon): returns true if harmless (plant, etc.)
# detect_monster_radius(rad, option): Find all monsters at an exact radius, option always "single" for now
# detect_monsters(): wrapper for detect_monster_radius
# find_closest_monster(): returns the x and y coordinate of the closest monster, using detect_mmonster_radius()

include = situation.rc

####################################
# Equipment Functions              #
####################################

# equip.rc functions:

# detect_items(): returns a list of visible items on the floor, each entry is (xpos, ypos, item)
# 

include = equip.rc

----------------------
-- Moving Functions --
----------------------
{

function autotravel()
  crawl.mpr(you.branch())
  magic("o")
end

function autoattack()
  magic("\t")
end

-- Change this once our current goal is past temple
function descend()
  magic("G>")
end

-- This function is outdated to when food was in several different categories
function eat_permafood()
  local this_item
  local i, a, b
  for i = 0, 51 do
    this_item = items.inslot(i)
    if (this_item ~= nil) then
      a, b = find(list_of_permafood, this_item:name())
      if (a ~= -1) then
        magic("e" .. items.index_to_letter(i))
        return 0
      end
    end
  end
  crawl.mpr("No permafood, this is a problem")
  return 1
end

function eat()
  eat_permafood()
end

function rest()
  magic("s")
end

-------------------
-- Main Function --
-------------------

--Note that for hunger: 4 = satiated
--                      3 = hungry
--                      2 = very hungry
--                      1 = near starving
--                      0 = starving

function choose_stat_gain()
  return "s"
end

--This is the function which runs automatically at the start of the turn by Crawl.
--Determines the state of the game, and executes the appropriate action
function ready()
  local monx, mony = detect_monsters()
  local hung = you.hunger()
  local cur_danger = detect_danger()
  local chp, mhp = you.hp()
  local berserk = you.berserk()

  crawl.more_autoclear(1)

  if (cur_goal == "debug") then
    if (berserk) then
      cur_goal = "explore"
    end
  else

    if (prev_turn == you.turns()) then
      --crap, we failed to do anything this turn... Hopefully because the floor is done
      non_moves = non_moves + 1
      crawl.mpr(tostring(non_moves))
    else
      non_moves = 0
    end

    if (non_moves > 20) then
      cur_goal = "descend"
      descend()
      non_moves = 0
    elseif (hung == 0) then
      cur_goal = "eat"
      eat()
    elseif (monx ~= 0 or mony ~= 0) then
      cur_goal = "fight"
      crawl.mpr(tostring(cur_danger))
      if ((cur_danger > danger_limit) and (berserk == false)) then
        magic("aa")
      end
      autoattack()
      --eventually change this to retreat/fight
    elseif (hung <= 1) then
      cur_goal = "eat"
      eat()
    elseif ((berserk) or (chp < 0.9*mhp) or (you.exhausted())) then
      cur_goal = "rest"
      rest()  
    elseif (cur_goal == "manage_inv") then
      equip_best()
--    magic_string = drop_useless(magic_string)
--    magic(magic_string)
      cur_goal = "explore"
    else
      autotravel()
      cur_goal = "manage_inv"
    end
  end
  prev_turn = you.turns()
  crawl.mpr(cur_goal)
end
}

######################################
# Initialization of important fields #
######################################

:cur_goal = "explore"
:non_moves = 0
:prev_danger = 0
:prev_turn = -1
:list_of_permafood = {"ration"}
:list_of_harmless = {"plant", "bush", "fungus"}
:list_of_dangerous = {"orc warrior", "orc priest"}
:danger_limit = 2
:initialized = 0


